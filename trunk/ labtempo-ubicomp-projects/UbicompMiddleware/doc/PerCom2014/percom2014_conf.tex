
%% bare_conf.tex
%% V1.3
%% 2007/01/11
%% by Michael Shell
%% See:
%% http://www.michaelshell.org/
%% for current contact information.
%%
%% This is a skeleton file demonstrating the use of IEEEtran.cls
%% (requires IEEEtran.cls version 1.7 or later) with an IEEE conference paper.
%%
%% Support sites:
%% http://www.michaelshell.org/tex/ieeetran/
%% http://www.ctan.org/tex-archive/macros/latex/contrib/IEEEtran/
%% and
%% http://www.ieee.org/

%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE! 
%% User assumes all risk.
%% In no event shall IEEE or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%

%% All comments are the opinions of their respective authors and are not
%% necessarily endorsed by the IEEE.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%
%% File list of work: IEEEtran.cls, IEEEtran_HOWTO.pdf, bare_adv.tex,
%%                    bare_conf.tex, bare_jrnl.tex, bare_jrnl_compsoc.tex
%%*************************************************************************

% *** Authors should verify (and, if needed, correct) their LaTeX system  ***
% *** with the testflow diagnostic prior to trusting their LaTeX platform ***
% *** with production work. IEEE's font choices can trigger bugs that do  ***
% *** not appear when using other class files.                            ***
% The testflow support page is at:
% http://www.michaelshell.org/tex/testflow/



% Note that the a4paper option is mainly intended so that authors in
% countries using A4 can easily print to A4 and see how their papers will
% look in print - the typesetting of the document will not typically be
% affected with changes in paper size (but the bottom and side margins will).
% Use the testflow package mentioned above to verify correct handling of
% both paper sizes by the user's LaTeX system.
%
% Also note that the "draftcls" or "draftclsnofoot", not "draft", option
% should be used if it is desired that the figures are to be displayed in
% draft mode.
%
\documentclass[conference]{IEEEtran}
% Add the compsoc option for Computer Society conferences.
%
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[conference]{../sty/IEEEtran}





% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)


% *** MISC UTILITY PACKAGES ***
%
%\usepackage{ifpdf}
% Heiko Oberdiek's ifpdf.sty is very useful if you need conditional
% compilation based on whether the output is pdf or dvi.
% usage:
% \ifpdf
%   % pdf code
% \else
%   % dvi code
% \fi
% The latest version of ifpdf.sty can be obtained from:
% http://www.ctan.org/tex-archive/macros/latex/contrib/oberdiek/
% Also, note that IEEEtran.cls V1.7 and later provides a builtin
% \ifCLASSINFOpdf conditional that works the same way.
% When switching from latex to pdflatex and vice-versa, the compiler may
% have to be run twice to clear warning/error messages.






% *** CITATION PACKAGES ***
%
\usepackage{cite}
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 4.0 (2003-05-27) and later if using hyperref.sty. cite.sty does
% not currently provide for hyperlinked citations.
% The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/cite/
% The documentation is contained in the cite.sty file itself.






% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
  \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  \graphicspath{./figures/}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi
% graphicx was written by David Carlisle and Sebastian Rahtz. It is
% required if you want graphics, photos, etc. graphicx.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at: 
% http://www.ctan.org/tex-archive/macros/latex/required/graphics/
% Another good source of documentation is "Using Imported Graphics in
% LaTeX2e" by Keith Reckdahl which can be found as epslatex.ps or
% epslatex.pdf at: http://www.ctan.org/tex-archive/info/
%
% latex, and pdflatex in dvi mode, support graphics in encapsulated
% postscript (.eps) format. pdflatex in pdf mode supports graphics
% in .pdf, .jpeg, .png and .mps (metapost) formats. Users should ensure
% that all non-photo figures use a vector format (.eps, .pdf, .mps) and
% not a bitmapped formats (.jpeg, .png). IEEE frowns on bitmapped formats
% which can result in "jaggedy"/blurry rendering of lines and letters as
% well as large increases in file sizes.
%
% You can find documentation about the pdfTeX application at:
% http://www.tug.org/applications/pdftex





% *** MATH PACKAGES ***
%
%\usepackage[cmex10]{amsmath}
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics. If using
% it, be sure to load this package with the cmex10 option to ensure that
% only type 1 fonts will utilized at all point sizes. Without this option,
% it is possible that some math symbols, particularly those within
% footnotes, will be rendered in bitmap form which will result in a
% document that can not be IEEE Xplore compliant!
%
% Also, note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/amslatex/math/





% *** SPECIALIZED LIST PACKAGES ***
%
\usepackage{algorithmic}
% \renewcommand{\algorithmicrequire}{\textbf{Input:}}
\newcommand{\algorithmicforeach}{\textbf{for each}}
\newcommand{\algorithmiconevent}{\textbf{on event received}}
\newcommand{\algorithmicendevent}{\algorithmicend\ \algorithmionevent}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment fo describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithms/
% There is also a support site at:
% http://algorithms.berlios.de/index.html
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithmicx/




% *** ALIGNMENT PACKAGES ***
%
%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/tools/


%\usepackage{mdwmath}
%\usepackage{mdwtab}
% Also highly recommended is Mark Wooding's extremely powerful MDW tools,
% especially mdwmath.sty and mdwtab.sty which are used to format equations
% and tables, respectively. The MDWtools set is already installed on most
% LaTeX systems. The lastest version and documentation is available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/mdwtools/


% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.


%\usepackage{eqparbox}
% Also of notable interest is Scott Pakin's eqparbox package for creating
% (automatically sized) equal width boxes - aka "natural width parboxes".
% Available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/eqparbox/





% *** SUBFIGURE PACKAGES ***
%\usepackage[tight,footnotesize]{subfigure}
% subfigure.sty was written by Steven Douglas Cochran. This package makes it
% easy to put subfigures in your figures. e.g., "Figure 1a and 1b". For IEEE
% work, it is a good idea to load it with the tight package option to reduce
% the amount of white space around the subfigures. subfigure.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at:
% http://www.ctan.org/tex-archive/obsolete/macros/latex/contrib/subfigure/
% subfigure.sty has been superceeded by subfig.sty.



%\usepackage[caption=false]{caption}
%\usepackage[font=footnotesize]{subfig}
% subfig.sty, also written by Steven Douglas Cochran, is the modern
% replacement for subfigure.sty. However, subfig.sty requires and
% automatically loads Axel Sommerfeldt's caption.sty which will override
% IEEEtran.cls handling of captions and this will result in nonIEEE style
% figure/table captions. To prevent this problem, be sure and preload
% caption.sty with its "caption=false" package option. This is will preserve
% IEEEtran.cls handing of captions. Version 1.3 (2005/06/28) and later 
% (recommended due to many improvements over 1.2) of subfig.sty supports
% the caption=false option directly:
%\usepackage[caption=false,font=footnotesize]{subfig}
%
% The latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/subfig/
% The latest version and documentation of caption.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/caption/




% *** FLOAT PACKAGES ***
%
%\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure. The latest version and documentation can be found at:
% http://www.ctan.org/tex-archive/macros/latex/base/



%\usepackage{stfloats}
% stfloats.sty was written by Sigitas Tolusis. This package gives LaTeX2e
% the ability to do double column floats at the bottom of the page as well
% as the top. (e.g., "\begin{figure*}[!b]" is not normally possible in
% LaTeX2e). It also provides a command:
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/sttools/
% Documentation is contained in the stfloats.sty comments as well as in the
% presfull.pdf file. Do not use the stfloats baselinefloat ability as IEEE
% does not allow \baselineskip to stretch. Authors submitting work to the
% IEEE should note that IEEE rarely uses double column equations and
% that authors should try to avoid such use. Do not be tempted to use the
% cuted.sty or midfloat.sty packages (also by Sigitas Tolusis) as IEEE does
% not format its papers in such ways.





% *** PDF, URL AND HYPERLINK PACKAGES ***
%
%\usepackage{url}
% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/misc/
% Read the url.sty source comments for usage information. Basically,
% \url{my_url_here}.





% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )


% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor UbiApp UbiComp}


\begin{document}
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
% \title{Interacting with the environment: a framework to develop ubiquitous applications for intelligent environments}
% \title{Encapsulating the environment: a flexible framework to develop ubiquitous applications for intelligent environments}
% \title{A flexible framework to develop ubiquitous applications for intelligent environments}
\title{A flexible framework to prototype, develop and manage ubiquitous applications for intelligent environments}

% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
% \author{\IEEEauthorblockN{Matheus Erthal}
% \IEEEauthorblockA{Institute of Computing\\
% Federal Fluminense University\\
% Rio de Janeiro, Brazil\\
% Email: merthal@ic.uff.br}
% \and
% \IEEEauthorblockN{David Barreto}
% \IEEEauthorblockA{Institute of Computing\\
% Federal Fluminense University\\
% Email: dbarreto@ic.uff.br}
% \and
% \IEEEauthorblockN{Douglas Mareli}
% \IEEEauthorblockA{Institute of Computing\\
% Federal Fluminense University\\
% Email: dmareli@ic.uff.br}
% \and
% \IEEEauthorblockN{Orlando Loques}
% \IEEEauthorblockA{Institute of Computing\\
% Federal Fluminense University\\
% Email: loques@ic.uff.br}}

% \author{\IEEEauthorblockN{Michael Shell}
% \IEEEauthorblockA{School of Electrical and\\Computer Engineering\\
% Georgia Institute of Technology\\
% Atlanta, Georgia 30332--0250\\
% Email: http://www.michaelshell.org/contact.html}
% \and
% \IEEEauthorblockN{Homer Simpson}
% \IEEEauthorblockA{Twentieth Century Fox\\
% Springfield, USA\\
% Email: homer@thesimpsons.com}
% \and
% \IEEEauthorblockN{James Kirk\\ and Montgomery Scott}
% \IEEEauthorblockA{Starfleet Academy\\
% San Francisco, California 96678-2391\\
% Telephone: (800) 555--1212\\
% Fax: (888) 555--1212}}

% conference papers do not typically use \thanks and this command
% is locked out in conference mode. If really needed, such as for
% the acknowledgment of grants, issue a \IEEEoverridecommandlockouts
% after \documentclass

% for over three affiliations, or if they all won't fit within the width
% of the page, use this alternative format:
% 
%\author{\IEEEauthorblockN{Michael Shell\IEEEauthorrefmark{1},
%Homer Simpson\IEEEauthorrefmark{2},
%James Kirk\IEEEauthorrefmark{3}, 
%Montgomery Scott\IEEEauthorrefmark{3} and
%Eldon Tyrell\IEEEauthorrefmark{4}}
%\IEEEauthorblockA{\IEEEauthorrefmark{1}School of Electrical and Computer Engineering\\
%Georgia Institute of Technology,
%Atlanta, Georgia 30332--0250\\ Email: see http://www.michaelshell.org/contact.html}
%\IEEEauthorblockA{\IEEEauthorrefmark{2}Twentieth Century Fox, Springfield, USA\\
%Email: homer@thesimpsons.com}
%\IEEEauthorblockA{\IEEEauthorrefmark{3}Starfleet Academy, San Francisco, California 96678-2391\\
%Telephone: (800) 555--1212, Fax: (888) 555--1212}
%\IEEEauthorblockA{\IEEEauthorrefmark{4}Tyrell Inc., 123 Replicant Street, Los Angeles, California 90210--4321}}


\author{\IEEEauthorblockN{Matheus Erthal\IEEEauthorrefmark{1},
David Barreto\IEEEauthorrefmark{1},
Douglas Mareli\IEEEauthorrefmark{1} and
Orlando Loques\IEEEauthorrefmark{1}}
\IEEEauthorblockA{\IEEEauthorrefmark{1}Institute of Computing\\
Federal Fluminense University\\
Rio de Janeiro, Brazil\\ 
\{merthal, dbarreto, dmareli, loques\}@ic.uff.br}}




% use for special paper notices
%\IEEEspecialpapernotice{(Invited Paper)}




% make the title area
\maketitle


\begin{abstract}
%\boldmath
% version 2
% Due to recent advances in mobile computing and wireless communication technologies, we can see the emergence of a favorable scenario for building ubiquitous/pervasive applications. This work proposes a framework that aims at building those applications, providing a set of concepts and implementation tools. We propose abstractions that allow developers to handle the resources spread in the environment in a simple and homogeneous way, and to interpret context information. In order to demonstrate the feasibility of the proposal, the concepts were implemented in a platform named \textit{\textit{SmartAndroid}}. A ubiquitous applications prototyping interface was implemented over this platform to allow testing of different environment configurations before purchasing all devices; and also a context rules composition interface, where end-users can define their preferences in the environment.

% version 3
% Due to recent advances in mobile computing and wireless communication technologies, we can see the emergence of a favorable scenario for building ubiquitous/pervasive applications. This work proposes a state-of-art framework for building those applications by solving some of the main issues of the field, namely the heterogeneity of devices, the amount and diversity of context information and services, and the difficulty of developing and testing ubiquitous applications. The abstractions provided, and the management services conceived, allow developers to handle resources spread within the intelligent environment in a simple and homogeneous way. Furthermore, they enhance the capability of implementing context-aware applications, while still keep the flexibility on developing such applications. In order to demonstrate the applicability of the proposal, we implemented the concepts in a platform named \textit{\textit{SmartAndroid}}, which contemplates most of the framework's features and has enabled the construction of a set of example applications to validate the framework. Above the platform we implemented a management and prototyping interface that uses a tablet device to allow the testing of applications running on different configurations of the environment. This intelligent environment may be populated with physical and/or virtual resources, what enables the emulation of devices as well as the simulation, without the need of purchasing all those devices. The interface also allows the composition of context rules either by developers or non trained users.

% version 4
Due to recent advances in mobile computing and wireless communication technologies, we can see the emergence of a favorable scenario for building ubiquitous/pervasive applications. This work proposes a state-of-art framework for building those applications by solving some of the main issues of the field, namely the heterogeneity of devices, the amount and diversity of context information and services, and the difficulty of developing and testing ubiquitous applications. The abstractions provided, and the management services conceived, allow developers to handle resources spread within the intelligent environment in a simple and homogeneous way. Furthermore, they enhance the capability of implementing context-aware applications, while still keep the flexibility on developing such applications. In order to demonstrate the applicability of the proposal, we implemented the concepts in a platform named \textit{SmartAndroid}, which contemplates most of the framework's features and has enabled the construction of a set of example applications to validate the framework. Above the platform we implemented a management and prototyping interface that uses a tablet device to allow the testing and evaluation of applications running on different configurations of the environment. This intelligent environment may be populated with a mix of simulated and real devices, what may reduce the costs of prototyping. The interface also enables the end-user programming of context rules through a high level user interface.
% Above the platform we have developed a management and prototyping interface that uses a mobile device such as a tablet to allow the testing and evaluation of ubiquitous applications. Therefore it is possible to execute a wide range of scenarios, using a mix of simulated and real devices. This interface also permits end-user programming of context rules through a hi-level user interface.



% This intelligent environment may be populated with physical and/or virtual resources, what enables the emulation of devices as well as the simulation, without the need of purchasing all those devices. 
% 
% The interface also allows the composition of context rules either by developers or non trained users.
% 
% In addition, we have developed a management and prototyping interface, which runs in a mobile device such as a tablet, that allows testing and evaluation of ubiquitous applications. 
% 
% Therefore it is possible to execute a wide variety of scenarios, using a mix of simulated and real devices. This interface also permits end-user programming of context rules through a hi-level user interface.


% This intelligent environment may be loaded with the representation of physical resources and/or simulators, what enables the prototyping of applications without the need of purchasing all those devices.
 
% This intelligent environment may be loaded with the representation of physical and/or virtual resources, what enables the prototyping of applications without the need of purchasing all those devices. 

% With the purpose of evaluating the proposal we implemented the concepts 
% and enable the context interpretation and 
%  even without the need of purchasing all those devices
%  (with a touch screen interface)
% The abstractions provided, and the management services conceived, allow developers to handle resources spread within the intelligent environment in a simple and homogeneous way, and enhances the capability of implementing context sensitive applications, while still keep the flexibility on developing such applications. 
% Above the platform we implemented a management and prototyping interface that uses a tablet device to allow the testing of applications running on different configurations of the environment, which may be loaded with simulators or the representation of the resources. The interface also allows the composition of context rules either by developers or non trained users.

% This work proposes a framework that aims at building those applications, providing a set of concepts and implementation tools. We propose abstractions that allow developers to handle the resources spread in the environment in a simple and homogeneous way, and to interpret context information. In order to demonstrate the feasibility of the proposal, the concepts were implemented in a platform named \textit{SmartAndroid}. A ubiquitous applications prototyping interface was implemented over this platform to allow testing of different environment configurations before purchasing all devices; and also a context rules composition interface, where end-users can define their preferences in the environment.



% Context awareness is reaching increasingly visibility in the current applications development scenario. The goal of this paper is to propose a new solution for representing, distributing and interpreting context information, thus allowing the construction of applications for intelligent ambients. The infrastructure described in this paper exposes the ambient resources in a higher level, leading to a simpler and more dynamic creation of context rules; and by means of a graphical interface, end-users are able to easily create and customize rules in the ambient. The proposed concepts have been implemented as a platform focused on building smart homes.
% 
% This article describes the Pervasive Applications Prototyping and Management Interface (IPGAP) that aims to provide a platform to support construction, test and execution of applications for smart ambients. In order to provide these features capabilities, our tool helps to perform simulation of sensors and actuators as well as means to visualize the interaction of real components which are inside the ambient. This way the developer will be able to construct applications without having a complete smart ambient infrastructure.

\end{abstract}
% IEEEtran.cls defaults to using nonbold math in the Abstract.
% This preserves the distinction between vectors and scalars. However,
% if the conference you are submitting to favors bold math in the abstract,
% then you can use LaTeX's standard command \boldmath at the very start
% of the abstract to achieve this. Many IEEE journals/conferences frown on
% math in the abstract anyway.

% no keywords




% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              SECTION
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
% no \IEEEPARstart
% You must have at least 2 lines in the paragraph with the drop letter
% (should never be an issue)
The idea of Ubiquitous Computing (UbiComp), nowadays widely discussed, was first proposed by Mark Weiser in the 1990's~\cite{Weiser1991century}. Also referred by pervasive computing, the field aims at providing a different paradigm of human-machine interaction. As traditional applications provides services to users through their explicit commands (using devices as mouse, keyboard, monitor, for example), in ubiquitous applications (UbiApp) the interaction happens without the need of explicit interaction, i.e. the application tries to discover the users needs through the acquisition of context (using sensors) and the knowledge of their preferences, and providing services in the environment (using actuators). These environments enhanced with sensors and actuators to provide automated services to people are also called Intelligent Environments (IE).

% The construction of a UbiApp from the start is not a simple task, since the developer will have concerns from the communication level to the representation of resources in high level before even start programming the business logic of her application. 
The construction and manipulation of UbiApps represent major challenges for developers, especially in terms of technical knowledge required and the availability of real devices during the application development. Some of these challenges can be well highlighted: (i) there are difficulties in establishing a common protocol for communication between the components of the distributed system, because of the \textit{heterogeneity of devices} involved, (ii) the interactivity of UbiApps is hampered depending on the amount and \textit{variety of context information and services} available in the environment, (iii) \textit{developing and testing applications} require high availability of resources, such as sensors (e.g. presence, lighting, temperature), actuators (e.g. keys, alarms, smart-tvs) and other devices, and the availability of physical spaces, such as a house for smart home applications.
% (iii) \textit{developing and testing applications} require high availability of resources, such as sensors (e.g. presence, lighting, temperature), actuators (e.g. keys, alarms, smart-tvs), including new embedded devices, or physical spaces, such as a house for applications of type smart home.



% From the Mark Weiser proposed in the 1990s, researchers in the field of ubicomp / pervasive have proposed changes in human-machine interaction, in order to make the use of devices increasingly transparent environment. This enables the user to focus on the task at hand and not the tool to do it. From these ideas came the concept of smart environments, where sensors and actuators interconnected network are able to provide relevant information about the environment to applications and users, and effectively act in this environment and change its state.



%FIXME: araujo é um artigo em PT, arrumar um em EN
In this work we propose a framework for developing UbiApps in IE. The goal is to provide support for the programming, testing and execution of applications, thus allowing to deal consistently with systems of great complexity. The framework stands out for addressing the challenges already identified in UbiComp~\cite{araujo2003}. The \textit{heterogeneity of devices} is handled through the definition of a Distributed Component Model, that provides abstractions to encapsulate these devices, also called resources, enabling developers to interact with them seamlessly. Regarding the \textit{variety of context information and services} issue, we propose a solution for context interpretation that allows developers to create and manage context rules at runtime, and users to set their preferences in the IE. Finally, regarding the issue on the \textit{resource availability}, the framework includes the Prototyping Interface for Pervasive Applications (PIPA), focused on visualization and testing UbiApps, capable of mixing real and virtual components.
% which allows the management of UbiApps and the prototyping 
% an application interface for the prototyping and management of pervasive applications (IPGAP), focused on visualization and testing UbiApps, mixing real and virtual components.

%in which the basic component has a uniform structure defined as a Resource Agent (RA), formerly proposed in~\cite{cardoso2006} as an entity gathering context information. In this work, the RA, while maintaining context information, acts as a component that encapsulates the device code associated with it, including aspects of interaction with application components. 
%The \textit{heterogeneity of devices} is handled through the definition of a Distributed Component Model, in which the basic component has a uniform structure defined as a Resource Agent (RA), formerly proposed in~\cite{cardoso2006} as an entity gathering context information. In this work, the RA, while maintaining context information, acts as a component that encapsulates the device code associated with it, including aspects of interaction with application components. 

The concepts of the framework were materialized on a platform called \textit{SmartAndroid}~\footnote{For more information visit www.tempo.uff.br/smartandroid}, whose development has enabled appraisal in order to prove that the conceptual framework facilitates the process of building UbiApps. We implemented example applications to validate different aspects of the framework proposed and to testify its capabilities.%, supported by the elaboration of competency questions, which is a mechanism mostly used to evaluate ontologies, but can also be used as an assessment to this work. 

The remainder of this paper is organized as follows. First we compare our approach with related works in Section~\ref{sec:related}, then in Section~\ref{sec:overview} we present an overview of the main concepts used as a basis for the development of the framework. In Section~\ref{sec:framework}, we describe the framework's overall architecture as well as, in Section~\ref{sec:features}, its most important features. Our framework reference implementation as the assumptions, techniques and features related are discussed in Section~\ref{sec:smartandroid}. A proof of concept demonstrating the feasibility of building UbiApps using the framework is presented in Section~\ref{sec:evaluation}, showing examples of applications that explores the key features of the IE. Finally, in Section~\ref{sec:conclusion} we conclude this paper with the main remarks and future works.


%The remainder of this paper is organized as follows. First we present in Section~\ref{sec:overview} an overview of the main concepts used as a basis for the framework's development. In Section~\ref{sec:framework}, we present the framework's overall architecture and main features. We then, in Section~\ref{sec:evaluation}, present a proof of concept demonstrating the feasibility of building UbiApps using the framework and we show examples of applications that explores the key features of the IE. Finally, in Section~\ref{sec:related} we compare our approach with related work and in Section~\ref{sec:conclusion} we conclude this paper with the main remarks.
% [refactor this paragraph]


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              SECTION
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work} \label{sec:related}
% [ubicomp is nice but it is not priceless]
The benefits to users and developers that UbiComp foresees reach beyond the horizon of many imaginative researchers. The possibilities that arise from it surpass the bounds established by common interface devices, such as mice, keyboards and touch screens. Nonetheless, building such adaptable applications requires much effort from developers who see themselves immersed in a universe of device's specifications and communication technologies, apart from the problem itself that the application must solve. Therefore, many researchers have focused on diminishing those obstacles by providing abstractions, middlewares, services, tools, and other supportive techniques, not only for development but also for the prototyping of UbiApps.

%ubicomp implies dealing with limited and dynamically varying computational resources [kindberg2002ieee]

% The works that focus on context interpretation/context rules
% Some works focus on composing and managing context rules  %About the adaptability 
%Challenges in Access Right Assignment for Secure Home Networks - 17

% [best classical references]
% \cite{satyanarayanan2001pervasive}
% \cite{Park2007simulation}
% 
% \cite{dey2001conceptual}
% \cite{helal2005gator}
% 
% [others]
% \cite{brush2011home}
% \cite{edwards2001home}
% \cite{garcia2010towards}
% \cite{baldauf2007survey}
% \cite{gu2005service}
% \cite{kindberg2002system}
% 
% [only old references]
% 
% [get references from this conference]


%TODO: Gator Tech
%generic reference architecture applicable to any IE 
%middleware layers:
%physical, sensor platform (OSGi , service, knowledge, context management, application

% [many researchers research but few people use]

% [compare based on flexibility]

% [compare based on user/developer center focus]

% [compare based on punctual solution]

% [explain that our solution strives to accommodate several problems of UbiComp and to be flexible enough to accommodate the others]

%%%%%%%%%%%%%%% HETEROGENEITY

%%%%%%%%%%%%%%% CONTEXT AWARENESS
%Context Toolkit - Dey
%also a famous approach
%we use these abstractions, the aggregation, interpretation, the widget
%This approach provides a starting point
% The Context Toolkit~\cite{dey2001conceptual} is a seminal work that provides a set of abstractions for the composition of reusable components that focus on context acquisition and interpretation to support rapid prototyping of context aware applications. 
The framework of Dey and Abowd~\cite{dey2001conceptual}, implemented by the Context Toolkit, is a seminal work for the supporting of rapid prototyping of context aware applications and provides a set of abstractions for the composition of reusable components that focus on context acquisition and interpretation. Another pioneer in the field, the Gaia middleware~\cite{ranganathan2003middleware} was designed to facilitate the construction of applications for IE. It consists of a set of core services and a framework for building distributed context aware applications. The Gaia embraces many goals that include the acquisition of context, the maintenance of hardware and software descriptions, mechanisms to find resources and to compose context rules, among others. However, these two approaches do not have concerns on the user side and their preferences, including the management and testing of UbiApps at user level.
% Being one pioneer in the field, 
%uses operating systems abstractions to define its architecture
%have many goals that include the provision of mechanisms of acquisition of context; composition of rules (using first logic order), 
%%maintenance of hardwares and softwares description and about applications; 
%search mechanism to find resources
%presence and execution status of resources
%interpretation mechanism that gathers and interprets information, as defined by programmers
%mvc
%The main goals of Gaia's approach are the acquisition of context by applications, the monitoring of entities location, the maintenance of hardwares and softwares descriptions, and 
%Active Spaces
%FIXME: second phrase was copied

% DIOS++
The framework proposed in DIOS++~\cite{liu2003dios++} offers abstractions to manipulate distributed sensors and actuators, a communication layer to manage these devices, and a distributed rule engine. But concerns on temporization of context rules and creation of rules at end-user level were not touched upon.

% CASS
The CASS~\cite{Park2007simulation} is a rule simulation environment that have a simple mechanism to discover possible conflicts between rules that are composed only using ``AND'' clause. However, it does not deploy the rules in a running environment.

%%%%%%%%%%%%%%%%%% PROTOTYPING
The DiaSim~\cite{bruneau2012} presents a simulator for pervasive applications, but does not support dynamic configuration of  entities in the system. Furthermore the work is not clear about the transparency between real and simulated devices. Other works on simulation of pervasive systems~\cite{barton2002ubiwise, nishikawa2006ubireal} provide a 3D visualization of the environment as in a game. It is possible to configure devices within the system and interact with them. However these works focus on interaction tests of devices and simulation of the physical environment, not worrying about context awareness.

The BASE~\cite{becker2003base} provides a minimal middleware for handling the resources by means of simple abstractions to access remote services and device-specific capabilities, but it focus only on the communication concern.
%%%%%%%%%%%%%%%%%% Specific purpose approaches
% Most approaches focus on one aspect of UbiComp, such as security~\cite{kim2010challenges}, location~\cite{}, context representation~\cite{}, SmartHome specific~\cite{dixon2012operating}, among others. [+++]
% There are works that focus on one aspect of UbiComp, such as security~\cite{kim2010challenges}, location~\cite{}

%%%%%%%%%%%%%%%%%% FOR SELLING
% [talk about market, which approach are already in use?] Google IS, onX


The solution presented in this paper strives to accommodate central issues in the development of UbiApps, as identified by the challenges (i), (ii) and (iii), and the cited related works. The conceptual framework we propose facilitates the construction of those applications but don't restrict its design and development options, being flexible enough to accommodate other concerns that are application or support system specific.
% We propose a framework that 


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              SECTION
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview} \label{sec:overview}
% [context/contx sensibility]
It is easy to notice that the context information is a first concern topic in ubiquitous systems. But what is ``context''? Many authors have proposed definitions to this concept, though most are little accurate~\cite{baldauf2007survey}. Synthesizing previous definitions, Dey and Abowd have proposed that context is ``any information that can be used to characterize the situation of entities (i.e., whether a person, place or object) that are considered relevant to the interaction between a user and an application, including the user and the application themselves''~\cite{dey2001conceptual}. In a IE ``places'' are the rooms, the floors of a building, or spaces in general that enable the localization of other entities, ``people'' are individuals that populate the environment and interact with it, and ``things'' are virtual representations of physical objects or software components.
%Considering the diversity of devices, systems and protocols, one 
%Many authors have proposed definitions to this concept, though most use examples to explain it or adopt a restrictive definition, that may not contemplate a set of systems. <- wrong. Most are wide or use synonyms
%Synthesizing previous definitions, Dey and Abowd have proposed that context is any relevant information used to characterize the situation of entities, specifically: people, places and things.

Context aware (or context sensitive) applications is a designation to those applications that not only are capable of knowing the context of the environment, but also react to it either by means of changing the environment or in a software level. Thus, the UbiComp is context aware by definition, but the reverse is not necessarily true, since a context aware system may not be designed for IE.
% TODO: citation

% [distributed systems]
Ubiquitous systems are a class of distributed systems. So, our approach incorporates well proven distributed system concepts that are essential to disseminate and manage context information. Besides this, a distributed component model is adopted to implement the entities that live and interact in the ubiquitous environment.
% FIXME: strange

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              SECTION
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Framework Architecture} \label{sec:framework}
% [framework description] 
The framework provides mechanisms typically required in context-aware applications focused on IE. Among the features is the ability to abstract details that involve communication, context acquisition and resource location, by the applications. For the sake of abstracting resource details we have used components called \textit{Resource Agents} (RA). The RA is the basic modularization unit of the framework being used in the modeling, implementation and management of applications (Subsection~\ref{subsec:ra}). %Example?

% The decentralization of components of the framework (the RAs) follow the principles of the Service-oriented Architecture (SoA), where the more decentralization the more flexibility on connectivity, since the dependence of centralized services is lowered.

% Resolution of the issue is achieved through the decentralization of services, using service-oriented architecture (SoA). The use of SOA enables the relationship between different entities, where the greater decentralization connectivity is more flexible, since the dependence of a service center is minimized. Therefore, problems in a system component are softened and can be absorbed by mechanisms of fault tolerance and persistence.

% Thus, to expose services following the style SoA, other components can access it uniformly reducing the complexity of integration. For example, details of data collection from a temperature sensor are known internally by AR, which is responsible for providing a simple interface to other system components, such as collecting the temperature in Celsius (C) or Fahrenheit (F) that internally, the sensor represented is captured in Kelvin (K).

% [distributed components model]

% The general architecture of the framework is expressed in a form of a distributed components model, which defines the RA structure 
The general architecture of the framework includes a Distributed Components Model, which defines the RA structure and the Resource Management Support Services. The Figure~\ref{fig:arch} presents a layered architecture that highlights main aspects of the framework. The layers are composed as follows.

% [architecture picture]
\begin{figure}[ht]
\centering
\includegraphics[width=3.5in]{figures/architecture-refactored-v2.pdf}
\caption{Framework Layer Architecture}
\label{fig:arch}
\end{figure}

\subsubsection{Physical Resources Layer}
The deepest layer is the one where are found the resources present in the environment. In a IE these resources are the smarter versions of daily used objects, such as beds, stoves, TVs, clocks, and so on. Since all these resources have their own mechanisms of communication and operation, then a higher level entity is required to deal with them.

\subsubsection{Middleware Layer}
This layer comprehends the main services that sustain the interoperability of the RAs and provides basic features for the development of UbiApps. The management services and the RA Repository, that compose the middleware, will be further discussed in Subsection~\ref{subsec:sgar}.
% Below the management services a RA Repository keeps , that  as will be further discussed in Subsection~\ref{subsec:sgar}, 

\subsubsection{Resource Agents Layer}
This layer is composed by all the RAs that represent physical resources already living in the IE. The RA will be presented in Subsection~\ref{subsec:ra}.

\subsubsection{Applications Layer}
The higher layer includes all UbiApps that are enjoying the middleware features and also all the software level RAs, which are represented in the figure by the ``Forgotten Stove Interpreter'' and the ``Reminder Actuator''.


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              SECTION
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FIXME: Framework Details????????????????????
\section{Framework Features} \label{sec:features}
This section describes details of the main features provided by the framework, which includes the RA definition (Subsection~\ref{subsec:ra}), the management services (Subsection~\ref{subsec:sgar}) and the context interpretation (Subsection~\ref{subsec:ci}). In the next section (Section~\ref{sec:smartandroid}) we will present the current status of the implementation.
% This section approaches the main features provided by the framework, which includes the definition of the RA (Subsection~\ref{subsec:ra}), the management services (Subsection~\ref{subsec:sgar}) and the context interpretation (Subsection~\ref{subsec:ci}). Also, based on the reference implementation, an application was built to provide a tool for the prototyping, management and visualization of applications and resources running on the IE.

  \subsection{Resource Agents} \label{subsec:ra}
  % [resource]
  % A resource may be defined as any hardware or software entity that exposes services which can be used by other entities and applications present in IE. Thus, sensors, actuators and smart devices (e.g. stove, fridge, air-conditioning) fall within this definition. For example, a light bulb can expose a service to get its current state (either on or off) and another to effectively turn it on and off. A software module that monitors all these light bulbs turned on, deduce the power consumption and expose this information is also an example of resource.

  A resource may be defined as any hardware or software component that exposes services (of data acquisition or actuation) which can be used by other entities and applications present in IE. Thus, sensors, actuators and smart devices (e.g. stove, fridge, air-conditioning), as well as software modules that provide a service to the IE, fall within this definition. 

  The RAs are entities that represent resources. They encapsulate the specificities of resources and expose their information to the IE through standard interfaces, so that others can access them uniformly reducing the complexity of integration. 

  The Dey and Abowd's definition to context proposes three entities as the most basic of a ubiquitous system, i.e. person, place and object (or thing). Regarding these definitions, we have conceived all these three entities as RAs on the framework, but observed their particular features. Thus they inherit the convenience of being a RA.

  % The Resource Agents (RA) can be understood as entities that represent resources, which are sensors, actuators, devices, and smart appliances, as well as software modules that provide a service to the environment. The RAs encapsulate the specificities of resources and expose their information to the environment through standard interfaces, so that others can access them uniformly reducing the complexity of integration. For example, data collection details from a temperature sensor would be known only by their RA, which is responsible for providing a simple interface to other system components.
  %it's similar to the widget of the context toolkit
  %enjoys benefits of SOA

  %From gator tech:
  %decoupling sensors and actuators from sensor platforms ensures openness and makes it possible to introduce new technology as it becomes available

%  [wrapper]

    \subsubsection{RA Interfaces}

    The RA architecture includes two options of interface used for different purposes. The former provides access to Context Variables (CV) and is responsible for exposing the context information from the RA. The latter is called Operation (OP) and is responsible for exposing internal attributes (reading) or activating internal attributes (writing) belonging to RAs, enabling applications to manage RA's internal state and explicitly interact with the environment.    
    % In the previous example, the ``oven is turned on'' and the ``oven temperature in ºC'' are the some of the RA's CVs. 

    Consider the simple example of a smart stove where the instantiation of its RA exposes services to get its current context (e.g., oven is turned on, oven temperature in $\,^{\circ}\mathrm{C}$) and services that may change its context (e.g., turn oven off, set temperature to $100\,^{\circ}\mathrm{C}$). Hence, the RA concept meets the first challenge, which is the \textit{heterogeneity of devices} (i), since decoupling sensor and actuator from the sensor platforms favors the flexibility. 

    % The RA are distributed components that can be used to 
    
    \subsubsection{Communication}

    % [communication mechanisms]
    % The communication performed between two different RAs or between an RA and an application is developed through '
    % Towards implementing 
    In order to meet requirements typical of distributed environments, two communications mechanisms have been included in the framework: a standard Remote Procedure Call (RPC), that implements request-reply communication; and a publish-subscribe mechanism (pub-sub)~\cite{eugster2003many}, that implements asynchronous communication. The RPC is used to access directly the RA, querying for its context by accessing its CVs, or calling its internal OPs. On the other hand, through the pub-sub a RA can subscribe to a CV of another one (consumer role) and further receive a notification, when the first RA publishes its CV state change (provider role).
    
    The framework includes a RA Name System (RANS), that allows its unique identification in the IE. This identification is directly mapped to the Internet DNS, thus the names remain the same even if the network address (IP) changes, the only change is the updating of the addressing table. This naming and addressing scheme can be generalized to work over the Internet, and comply with the Internet of Things concept.

    \subsubsection{RA Structure}
    In analogy to object-oriented programming we define classes of RAs to represent the type of the resource with specific interfaces. Besides other information present in the RA's structure (such as name, location, subscribed RAs, among others) it has its type hierarchy. The type hierarchy allows the classification of RAs by a sequence of classes, and has been inspired by the ontology described in Ranganathan~\cite{ranganathan2005olympus}. In the Subsection~\ref{subsec:sgar} we will present how this feature can be used to find a RA and to define its functionalities.
    %The type hierarchy is composed by a sequence of classes that classify the entity and has been inspired by the ontology described by 

  \subsection{Resource Management Support Service} \label{subsec:sgar}
  A set of services is responsible for providing basic functionalities to manage the RAs. The four main services are the RA Register Service (RRS), the RA Discovery Service (RDS), the RA Location service (RLS) and the Security Management Service (SecMS). All these services access the RA Repository (RR) that maintains information about the RAs (addresses and descriptions) and the map data structure (map of the environment). The Figure~\ref{fig:arch} represents, in the Middleware layer, the RR and above it the management services.

  The management services are also designed as RAs, hence they take advantage of the communication mechanisms already provided by it and can communicate using the same primitives. 

    \subsubsection{RA Register Service} 
    The RRS allows the registration and deregistration of instances references and descriptions of RAs. This service also has CVs that allows the developer to know when a RA enters and leaves the IE

    \subsubsection{RA Discovery Service}
    The RDS allows the search for registered RAs based on specific attributes, which are the name, RANS and type of the RA. The search by RANS will only return one RA, but the search by name or type will return all RAs that meet this criteria.

    After the discovery of a RA, the stakeholder can instantiate a stub (i.e. a proxy) of this RA, if both the stub and the current implementation of the RA implement the same interface. Through the stub the CVs and OPs can be accessed, what internally will be converted to network calls to the RA instance (RPC functioning). 

    During the application initialization the only information required to get started is the RDS address. This information can be obtained, if within a LAN, by sending a broadcast message with the request; or using the embedded DNS service, if within a WAN. With the RDS address on hands any RA can be found, including the other management services (i.e., the RRS, RLS and SecMS). 
    %, before doing the connections to RAs,

    \subsubsection{RA Location Service}
    The RLS explores the map of the environment to run the required queries. This service performs searches related to the location of RAs, such as the physical location of RAs, the RAs located on some place, the RAs of some type located on some place, the RAs close to one another and ordered by proximity, among others. Thus, if a developer needs audiovisual devices close to some person, for example, she can run this search through the RLS and will receive a list, where an utility function can choose the more relevant result.
    
    The RLS exposes CVs that allows not only to query if a RA is located at a particular place, but also to subscribe to that place for the sake of being notified of the entrance or exit of a specified RA type. Therefore, even if the RA is still not registered, an application can subscribe to a place and wait for its appearance.

    Nowadays there are several technologies to map and/or track the location of entities, that may include from people to small things. These technologies vary mainly based on precision, ubiquity (capable of being ``invisible'') and price. As examples we have the GPS, the smart floor, cameras (associated to image processing softwares), Wi-Fi triangulation, RFID tags, and so on. In this approach we do not comply with any specific technology, and we assume that the RA can discover its own location or the RLS can.
    % already established technology of location

    \subsubsection{Security Management Service}
    The security concern is always a central topic on UbiComp systems, due to the diverse aspects of security required~\cite{kim2010challenges}. Some aspects are already inherited, depending on the technology adopted, e.g., the WPA protocol for \mbox{Wi-Fi} already ensures against the registration of outside devices and the secure exchange of information. %Thus our proposal for the the SecMS discusses requirements at a higher level, and issues at a lower level are defined according to the platform used.
    
    % [credentials]
    In UbiComp, any human-machine interaction should be as inconspicuous as possible. However, on what matters to end-users there is a need for authentication, what may be realized through explicit interaction, such as entering a password, fingerprint, eye retina recognition, and so on. Besides, other less intrusive ways are progressing, such as the facial recognition, though this raises privacy issues. On our approach, we do not specify which technology is used to guarantee the authentication. But we define user groups that restrict their access to domains in the IE. For instance, in a smart home the father and the mother may have administrative permissions, below them there are the other occupants (such as elderly and older children) that have a lower permission level, followed by the younger children and the guests at last.
    
%     The domains are responsible for grouping UbiApps with the same caracte
%     A domain may represent a set of UbiApps with
    A domain can represent a set of applications that share a common characteristic (e.g., home health care, home surveillance, multimedia), or a set of resource with the same constraints (e.g., adult, children, guest). Neither a user can manipulate resources or UbiApps that he has not permission to, nor an application can manipulate resources from outside its domain. The specification of domains complies with the theory of sets, thus an entity may be contained in more than one domain, and so on.
%     The SecMS allows modifications on security to take effect on the level of the middleware. 

%     On what matters to the users, there is a need to specify roles (or user groups) within the IE~\cite{brush2011home}. These roles would determine  For instance, in a smart home the father and the mother may have more permissions than the others (the administrators), below them there are the other occupants (such as elderly and older children), next the younger children, and lastly the guests.
    
%     In what concerns to the privacy of the UbiApps, we 
    % [domains]
    % The SecMS manages both the user's credentials and the application's domains.
    % 
    % On the 

  \subsection{Context Interpretation} \label{subsec:ci}
%   [motivation]
  Considering the multitude of resources present in the IE, the context interpretation aims at providing a higher level context information hence allowing the reuse of the logic and the separation of concerns. This feature helps to solve the challenge \textit{variety of context information and services} (ii), what is possible via the RA's interfaces, the CVs and OPs. 
  
  % [directly programmed]
  The context interpretation serves to aggregate context information from different sources in accordance with some specific logic and considering the passage of time. This logic is defined by the developer and the interpretation is implemented with the framework's support. %The CI concept was inspired by the Aggregator in Dey and Abowd~\cite{dey2001conceptual} whose objective was to gather logically related context and provides them in a single component.
  
  The entity that performs the context interpretation may be encapsulated by a RA, thus allowing the subscription to other RAs, what is called Context Interpreter (CI). This concept allows dealing with context in a higher level and also provides a separation on concerns, since a context interpreter decouples the steps for context acquisition, evaluation, timing and notification, that are repeatedly performed by the UbiApps. Therefore, using the CIs also promotes the reuse, either by the creator application or by other ones. 
  
  The framework uses a generic approach for creating context rules, which are composed by two parts: the interpretation and the actuation. The interpretation part, as already stated before, concerns on binding the CI itself with CVs from different RAs, evaluating the expression that interrelates those CVs, and notifying whoever is interested. The actuation part is a RA that is subscribed to the CI, and develop some job, that may change the context of the IE or change some state in a software level.
%   in which developers are able to define the logic of the rule in the application using the framework support for context acquisition, as well as to perform actions on the environment. 
  
  An example of context rules has been presented on Figure~\ref{fig:arch}. At the Applications Layer a set of two components implements the interpretation-actuation pattern: the ``Forgotten Stove Interpreter'' and the ``Reminder Actuator'' respectively, where the goal of the rule is to remind the elderly that he has forgotten the oven on while he went to sleep. The former component, which is a CI, is subscribed to two RAs, namely the ``Bed RA'' and the ``Stove RA'' (the dashed arrow means ``notify subscribers''). The latter is subscribed to the CI and calls the RAs, namely the ``TV RA'' and the ``Clock RA'', directly using RPC (represented by the straight arrow). Internally to the CI a rule expression relates the RAs as  ``bed is occupied and oven is turned on, for 30 min'', which means that the CI only will be valid if this condition remains true during ``30 min''. When the CI changes its state from invalid to valid (what includes the timing), the subscribers are notified, the ``Reminder Actuator'' in case. This actuator, in its turn, calls the OPs ``fire alarm'' from ``Clock RA'' and ``set message'' from ``TV RA'', with the parameter ``You forgot the oven on!''. Then it is expected that an accident is prevented.
  
%   In this simple example, the CI is subscribed to the RAs ``Bed RA'' and ``Stove RA'', and internally it contains the following rule expression: ``bed is occupied and stove is on for T min''. The actuator, awaits for when the condition of the CI met for triggering its action that, in case, is to play the clock's alarm sound and to show on TV a message saying that ``the stove has been forgotten''.
%   The Figure~\ref{fig:arch} shows on Applications Layer an example of a context rule with two components: the CI (``Forgotten Stove Interpreter'') and the actuator (``Reminder Actuator''). 

%   A avaliação da expressão é desempenhada pelo próprio IC quando o contexto muda. A atuação ocorre quando um agente atuador é subscrito à um IC, recebendo assim a notificação de que a expressão da regra foi avaliada como verdadeira. Estes agentes atuadores podem tanto ser atuadores simples, que desempenham ações sequencialmente no ambiente utilizando OPs diretamente (e.g., desligar lâmpada, gravar programação de determinado canal da TV); como atuadores mais complexos, que executam ações não necessariamente baseadas em OPs (e.g., execução de algum outro software, que utiliza um canal de emergência do serviço de saúde ou bombeiros).

% [talk more about actuators]
  An actuator can be simple as a list of actions to be invoked sequentially, such as in the previous example, or it can be more complex, for example, a program that does a mathematical calculation, or that aggregates other communication technology (such as SMS), and many others.
%   , e.g. a program that send a SMS message to some person in case of emergency, or that consults the weather from an website and shows on a visual interface at morning, and many others. 
    
%   [can have many actuators]
  The independence of the actuator allows its binding and unbinding with some CI in a easily manner, what is make possible because of the RA communication mechanism. Based on the same principle, more than one actuator can be bound to the same CI, for example, we may bind the forgotten stove CI with a ``family warning actuator'', that contacts a relative by phone and put her in touch with the elderly.

%   [timer can be CV]
  Another aspect of context rules is the time dimension. The definition of timers inside a rule expression can be done by subscribing the CI to a Timer RA, hence enabling the direct reference in the expression. The timer can also be relative or absolute. The absolute timer is objective: if the timer has reached some timestamp (e.g., 14:00), or if it is within a window of time (e.g., above 12:00 and below 14:00), then it is valid. The relative timer is more common, it counts the time from now until the specified timestamp (e.g., 30 min from now).
  
  % [ COMO É A TEMPORIZAÇÃO NO IC ]
% A temporização em um IC é definida ao se associar um ou mais temporizadores a uma subexpressão da regra (ou a expressão completa). Os temporizadores podem ser tanto relativos (e.g., fogão ligado e pessoa deitada na cama por 15min) quanto absolutos (e.g., ar-condicionado ligado às 18:00).

% [ INTERRUPÇÃO DE TEMPORIZADOR E AVALIAÇÃO DE REGRAS TEMPORIZADAS ]
% Durante a avaliação, se a expressão ou uma subexpressão que possuir um temporizador associado chegar em um estado verdadeiro, o temporizador é inicializado. Se, durante uma avaliação, a expressão ou subexpressão se torna falsa, então os temporizadores associados são interrompidos. Se o tempo limite é alcançado e se não há outros temporizadores associados a subexpressões da mesma regra em andamento, então os atuadores são notificados.
  
  
%   [how to aggregate others standards such as rule engines]
  % [rule engine]
  The solution for implementing the context rules within the framework may not be followed strictly as presented. The framework is flexible enough to permit other forms of context interpretation, such as by aggregating a off-the-shelf rule engine (e.g., Jess, Drools, Clips). A rule engine is a tool generally centralized, which receives context information from various sources and processes rules previously inserted, where it is common to use an algorithm such as RETE~\cite{forgy1982rete}, that processes rules built exclusively with the clause ``AND'', but very fast. Thus, the developer can use a different approach for rule processing but still enjoying the framework's features for context acquisition, discovery, and so on.
%Removi citação para ~\cite{kaczor2010rule}
  
%   Thus, developers can use their own standards, if appropriate. An alternative approach implemented in the context of middleware is to use the Context Processors (see Section 3.2).
  
%   The CI concept was inspired by the Aggregator in Dey and Abowd~\cite{dey2001conceptual} whose objective was to gather logically related context and provides them in a single component. However, in our approach, the information gathered compose a context rule whose evaluation returns true or false, and triggers an actuator listener. 
  
  
  
%   Through the CI the framework address the challenge (ii), which is related to the amount and diversity of context information and services, since the context interpretation allows the autonomous behaviour of RAs.
  
%   The RA can be used to aggregate information come from other RAs similarly to the Aggregator presented by Dey and Abowd~\cite{dey2001conceptual}.

  
%. This concept allows dealing with context in a higher level so that developers are free to focus on their business logic
  
\section{SmartAndroid} \label{sec:smartandroid}
% [android and other techs]
%We consolidated the concepts elaborated in the course of this project as the platform \mbox{\textit{SmartAndroid}}\footnote{For more information visit www.tempo.uff.br/smartandroid}. The project includes the implementation of APIs to , as well as prototyping and management interface on the Android platform.

%[David]
The conceptual framework proposed at this work was tested through a reference implementation called \mbox{\textit{SmartAndroid}}. The project includes a programming API to help the developers in constructing UbiApps as well as offers basic management services to provide resource registration, discovery and localization. The \textit{SmartAndroid} has been developed over Google Android platform as we believe that in a near future it can be widely used in sensors and devices embedded in furnitures and home appliances. In addition, this option helped us to implement emulators of several devices using cheap Android cellphones an tablets.

% [we have implemented most of the framework features, thought much more remain to be done]

%proposta de uso de marketplace
% A exposição de dados por meio de \textit{Content Provider} permite a integração de aplicativos externos ao servidor. Estes aplicativos podem ser dispostos em um \textit{marketplace} (http://developer.android.com/distribute/open.html) permitindo que tanto usuários comuns quanto programadores incrementem o ambiente com novas aplicações ubíquas. 
The \textit{SmartAndroid} middleware contemplates the possibility of running multiple applications in the same IE. Thus, focusing on the user and inspired by the Google Play -- which is a application market for Android devices --, we have as a future work the creation of a \textit{SmartAndroid} Market, where users will be able to easily download and start different applications. Also similar to the Google Play, a Manifest file will require permission for accessing the domains, what will allow users to maintain control over what off-the-shelf applications have permission to know and to do. Within the market, the UbiApp could be tested towards discovering any possible harm that the application could do and any possible inefficiency that could consume too much the energy resources of the host device.
% ~\cite{google2013}
% [security concern on store: helps the discovery of malware before the user download]

%   \subsection{Location}
%   
% %   [talk about location]
%   
%   The devices' indoor localization may be acquired through many different approaches, as an example, using radio frequency devices such as RFID tags and Wifi devices~\cite{Talukder2007Tracker} or even a smart floor~\cite{Branzel2013SmartFloor} which can locate people and objects by a pressure-sensing floor. However, the \textit{SmartAndroid} doesn't implement a specific technique to locate resources, in order to keep the framework generic. The \textit{SmartAndroid} API deal with location in a hi-level way, making the data acquirement transparent to it. This aspect is important to keep the system flexible to any approach, allowing the developer to use different implementations.
    
  \subsection{Communication Support}
  %[talk about stub intantiation calls]
  %TODO: example of CV and OP? Maybe it is worth add some on the text
  To perform any interaction with a RA that is not locally instantiated, the UbiApp must use a stub (also called proxy) that is bound to the referred RA. This stub implements the same interface as the RA, i.e. the same CVs and OPs, which are methods, from a Object-Oriented Programming perspective. The stubs could also be automatically generated since their role is to forward the calls to the implemented RA. With the stub on hands, the application can invoke remote methods, as if they were locally invoked. These remote methods may be to retrieve a CV or to trigger an OP. The Figure~\ref{fig:rpc} represents this direct, or synchronous, communication. The steps to achieve a direct communication, as represented by the figure, are as follows:
  \begin{enumerate}
    \item The UbiApp calls a method from the stub 
    \item The call is forwarded to the RA instance through the network in the second step
    \item This instance interacts with the device (i.e. the lamp)
    \item The result or the acknowledge is then returned to the caller
  \end{enumerate}
  %FIXME gain line: can remove work acknowledge
  
  \begin{figure}[ht]
  \centering
  \includegraphics[width=1.8in]{figures/comm-rpc.pdf}
  \caption{Direct communication} 
  \label{fig:rpc}
  \end{figure}
  
  It is possible to acquire the status of a CV directly, however it can also be done indirectly via the pub-sub mechanism, what makes it easier for developers being aware of CV change right away. This indirect, or asynchronous, communication is performed in two stages: the subscription (Figure~\ref{fig:pubsub}.a) and the notification (Figure~\ref{fig:pubsub}.b). During the first stage, represented by the Figure~\ref{fig:pubsub}.a, we have the following steps:
  \begin{enumerate}
    \item The UbiApp sets some RA (``RA X'') to subscribe to another, referred by its RANS (``Lamp RA'') and in a specific CV (``Is on'')
    \item Then the first RA requires to be subscribed to the second, through the network
    \item The second RA accepts the subscription and is bound to the device
  \end{enumerate}

  The second stage happens when the first RA is already subscribed to the second and a notification routine is triggered, what was represented by the Figure~\ref{fig:pubsub}.b and works as follows:
  \begin{enumerate}
    \item The device has its context changed, what may be caused directly (e.g., a person lights the lamp) or via the RA (i.e. an application, RA, or rule calls some RA's OP causing the context change)
    \item Then the device's RA notifies all subscribers of that CV (e.g., ``Is on'' from this Lamp RA)
    \item The subscriber calls a callback method of the UbiApp
  \end{enumerate}
  
  \begin{figure}[ht]
  \centering
  \includegraphics[width=3.4in]{figures/comm-pubsub.pdf}
  \caption{Indirect communication} 
  \label{fig:pubsub}
  \end{figure}
    
% 
%   \subsection{Distributed Components Model}
% %   [implementation of RA and services]
%   
%   [initialization]
% %   O \textit{SmartAndroid} é um aplicativo que inicializa o SGAR, repositório e serviços de comunicação. Este aplicativo deve ser executado em uma única unidade do ambiente, deixando o Deamon de Comunicação em estado de espera até receber requisições de outras aplicações. Em outras unidades (clientes) constam os aplicativos instalados com a biblioteca do \textit{SmartAndroid}, a qual é necessária para executar o serviço de comunicação e \textit{proxys} dos serviços do SGAR. Assim cada unidade pode consultar sobre IARs, através do SDR, obtendo seus ODARs, cada um com o respectivo RANS, o qual é utilizado pelo \textit{proxy} como referência de acesso. 
% 
% 
%   with the RANS 
%   RPC search 
% 
%   
%   [annotation]

%   \subsection{Resource Agent [?????]}
  
%   Inside the RA, 
  
  We have provided a simple implementation for the pub-sub mechanism, which was effective to evaluate our approach. The Figure~\ref{fig:ra-intercept} shows how we have implemented this mechanism using the RPC. In the example, two RAs (TV and Alarm Clock) subscribe to the Stove RA (step 1). Every RA keeps track of its stakeholders, where the stakeholder list keeps the RANS and the CV of interest. When a remote control (or another actuator) calls a OP that changes the state of the Stove RA (step 2), this is intercepted (step 3) and causes the selection of the stakeholders (step 4) followed by the notification (step 5) that also uses the RPC. 
  
  \begin{figure}[ht]
  \centering
  \includegraphics[width=3in]{figures/publish-subscribe-ar-en-v3.pdf}
  \caption{Resource Agent} 
  \label{fig:ra-intercept}
  \end{figure}
  
  
  \subsection{Context Rules Composition} \label{subsec:rules}
%   [implementation of context rules]
  The \textit{SmartAndroid} supports the context interpretation by providing mechanisms to create context rules. The composition of context rules can be done basically in two ways. The former is at the implementation level, where developers are able define their context rules in a description file or using a programming language. The latter is at end-user level, where non trained people are able to define their context rules supported by the PIPA (Subsection~\ref{subsec:ipgap}).
  
  The context rule life cycle has two major phases: composition and running. The composition phase corresponds to the instantiation of a CI and of an actuator and the binding of both through subscription. The running phase is when the CI and the actuator(s) are already instantiated as the other RAs that feed the IE with context information, and they are able to exchange messages and perform their job.
  %   Support the interpretation of the context framework enables a separation of concerns, where developers abstract implementation of contextual rules and focus on the application logic.
  
  At the implementation level, a context rule can be described in a JSON structured file (or byte stream) following a specific format, thus the CI code and the binding with the actuators can be automatically generated. The file must contain the CI definition with the rule expression, and may contain the definition of actuators too. This expression contains conditions that are the comparison of RA's CVs with constant values (e.g., Stove.OvenTemperature = $180\,^{\circ}\mathrm{C}$), of two different CVs from the same or from different RAs (e.g., ArConditioning.Temperature $>$ OutsideSensor.Temperature), or the RA's CV alone if it has a boolean value (e.g., Stove.IsOn). The conditions are bound to each other through the logical operators ``AND'' and ``OR'', it is also allowed the use of ``NOT'' and of parenthesis, what makes possible to compose more complex expressions by using subexpressions. The expression or subexpression may also contain a timer. 
  %TODO: explain why to use subexpressions (example: person at bed or at sofa)
  
  The definition of actuators is simpler than the definition of the CI and is not mandatory, since other actuators can be bound to the CI later. A actuator is composed by a list of actions, where each action have a RANS, a OP reference and the parameters (e.g., Stove.SetOvenTemperature to $100\,^{\circ}\mathrm{C}$). Both the actuator and the CI have a name, what makes it easier to search for them later.
  
  The \textit{SmartAndroid} has a parser that can read the JSON file and generates the instances of the CI and actuators. After reading the rule expression the parser creates a tree data structure that corresponds to that expression in memory, and the timers are also referenced within the structure. The CI queries all the CVs that appear on the expression to keep a cache of the context information and to start the evaluation. Next the CI subscribes to all these CVs and sets itself as ``running''. After the creation of the CI, the parser creates instances for the actuators, which are subscribed to the CI previously instantiated. 
  
  % [context rules conflicts is an ongoing study that aims at discover a conflict in runtime,]
  A common concern when having multiple context rules running in parallel is the occurrence of conflicts. The conflict happens when two CIs are be validated at the same time and the actuators associated with them have opposite actions. The conflict also happens when a context rule causes the triggering of another context rule, that may cause the triggering of the first one, leading to a circular deadlock. We have as a future work to focus on this concern and to provide a solution for the detection and resolution of conflicts.
%   , for instance:
%   % \vspace{-2mm} 
%   \begin{itemize}
%   % \begin{compactitem}[$\circ$]
%   \item IF stove is on and oven temperature $>$ 100 for 15min, then lower the temperatura;
%   \item IF stove is on and oven temperature $<$ 180 for 15min, then raises the temperature.
%   % \begin{compactitem}
%   \end{itemize}
%   % \vspace{-1.5mm}
  
  
%   The detection and resolution of conflicts aims at identifying the creation of contradictory rules and at providing a solution. The solution to this type of conflict involves the comparison of the expressions of a new CI with the existing (at the time of connection to the actuator) and, if found expressions that intercede, check the actions of the actuators to see if they are the same type but with different inputs.
  
%   A multiplicação de regras de contexto no AmbI, inclusive por diferentes usuários e aplicações, pode facilmente levar a casos de conflito. O conflito ocorre quando dois CIs possuem expressões que se intercedem enquanto os respectivos atuadores possuem ações opostas. Por exemplo, considere as seguintes regras:
%   % Neste caso, o fogão não foi ligado e esquecido, mas sim ligado para assar um bolo. 
%   O usuário criou uma regra para controlar a temperatura do fogão, quando já havia outra cadastrada que tinha ação oposta mas que poderia ocorrer ao mesmo tempo. As regras estão, portanto, em conflito, pois não está claro como o sistema deve agir.
%   %FIXME: compactar itemize
% 
%   % [ SOLUÇÃO PARA RESOLUÇÃO DE CONFLITOS ]
%   A detecção e a resolução de conflitos visam identificar a criação de regras contraditórias e prover uma solução, atendendo ao requisito de confiabilidade. A solução para este tipo de conflito envolve a comparação das expressões de um novo CI com as já existentes (no momento da ligação com o atuador); e, caso encontradas expressões que se intercedam, conferir as ações dos atuadores para ver se são do mesmo tipo mas com diferentes entradas. 


  
  \subsection{Interface for Management and Prototyping} \label{subsec:ipgap}
  %[description]\\
  %Entretanto, de modo geral essas aplicações ainda são auto-contidas, ou seja, não compartilham as informações geradas, nem expõem seus serviços no ambiente a fim de cooperar com outros aplicativos e provisionar serviços diferenciados para o usuário. O grande desafio da computação ubíqua/pervasiva  é justamente utilizar essas aplicações integradas a um ambiente inteligente, fornecendo seus serviços e informações à outras entidades.

  The success of the mobile applications market in the last few years has shown the trend for services to get closer to the users' everyday life. However, in general these applications are still self-contained, i.e., they do not share the information generated, nor expose their services in the environment in order to cooperate with other applications. So, the challenge for UbiComp is to make these limited applications be integrated with the IE and mutually share information and services, reaching a higher level of service provisioning. One of the reasons for the shortage of UbiApps on the market is the high cost in developing such applications, due to the lack of proper tools for the creation, integration and debugging of UbiApps~\cite{weis2007rapid}. In addition, the need for a testing environment filled with resources and the required infrastructure to perform them can be financially impractical, whereas an environment constructed on a small scale may not be sufficient to test several scenarios.
  %, thus providing differentiated services to the user
  %, one of the reasons may be the emergence of stable operational systems for mobile devices (e.g., Google Android, Apple iOS) and the .  
  
%   To help developers on prototyping and debugging their UbiApps, we propose the PIPA, which is a interface 
%   The main purpose of the PIPA is to provide a hybrid environment to developers where simulated and real resources can interact to each other transparently, enabling their users to start the UbiApp, test and evaluate them through a wide variety of scenarios. The RAs for sensors, actuators and household appliances are graphically represented at our tool, along with a schematic map of the IE so that some of the resources aspects, as its context and location, can be easily visualized on the map, helping the debug of applications. The resources are represented as icons that can be moved around the map in order to simulate the intended application behavior. For example, an alarm message can be displayed on the TV screen placed where the person is seated watching the TV.

%   The PIPA operates with two different interfaces: the \textit{developer interface}, already mentioned, and the \textit{end-user interface}. In the end-user interface, users in general, i.e. non-technical users, are able to use PIPA to manage their IE remotely using a mobile device, such as a tablet. Through an intuitive GUI, end-users can not only visualize the state of their home devices but control them. For instance, it's possible to turn off a stove burner, to change the air-conditioner temperature, and so on. By touching the device icon in the screen, an interface that presents the device's main functions is shown, where the user can operate it as a remote control.
  
  The PIPA is a multipurpose interface that accommodates features for UbiApps developers as well as non-trained end-users, and address the third challenge: \textit{developing and testing applications} (iii). The interface, as shown on Figure~\ref{fig:ipgap}, presents a schematic map of the environment (a smart home, in case) that is composed by the rooms informations come from the RLS and the representations of RAs, that are the sensors, actuators and other appliances present within the map. Although everything in the interface are representations, their instance can be of simulated or real resources, since it is transparent to the PIPA user. This hybrid approach allows developers to compose a scenario mixing real and simulated resources to test their UbiApp prototype or context rules, and it also allows end-users to evaluate a configuration for a IE. 
  
  From the developer point of view, the PIPA is a debugging toolbox. Through this interface the developer can create avatars to represent people, and simulators for the resources, and can control them using the same device or other ones (i.e., other smartphones and tablets). During the UbiApp execution it will be presented on the screen the changes in CVs (written below the icons) and the changes in position (position of the icon changes). The icons can be dragged and dropped to change the position of resources or to simulate people walking, in order to watch the application behavior, and if the icon is double-tapped a interface with its simulator is opened. The menu present in the bottom of Figure~\ref{fig:ipgap} offers options for creating simulators, loading existing RAs (with graphical representation), to show the log, to create context rules, and others. 
  
  % [main figure]
  \begin{figure}[ht]
  \centering
  \includegraphics[width=3.5in]{figures/map-forniture-cv-menu-big-v2.pdf}
  \caption{Management and Prototyping Interface} %PIPA
  \label{fig:ipgap}
  \end{figure}
  
  From the end-user point of view, the interface is a toolbox too, used to configure the IE and evaluate it without the need of buying all the resources. New off-the-shelf resources can also be tested if the manufacturer provides the simulator. Besides, the PIPA can be used to manage the real resources present within the IE. If an icon is double-tapped and it corresponds to a real resource, a remote control will open for the user (see Subsection~\ref{subsec:remote}).
  
  % [rules composer]
  Towards the composition of context rules at a high level either by end-user or developers, the PIPA offers a use mode where the users are able to define the rule expression, what automatically generates the CI, and the actions to be performed, what automatically generates an actuator the the binding with the CI. When the context rule is finished, the \textit{SmartAndroid} writes down this rule in a JSON file respecting the standard, thus if the system crashes or terminates, all the composed rules can be afterwards re-started by the context rules factory. 

  A rule such as the ``Forgotten stove'' can be easily composed in the PIPA. The procedure has the following steps:
  \begin{enumerate}
   \item Set the ``Compose a Context Rule'' mode (in the bottom of the Figure~\ref{fig:ipgap})
   \item Define the rule expression by touching the resources on the screen, selecting the CVs (Figure~\ref{fig:ipgap} shows the CV belonging to the stove) and choosing comparison operators, logical connectives and timers on a menu that appears at the center of the screen -- a side menu shows the rule being composed
   \item Define the actions after the finalization of the rule expression, the PIPA changes its mode to allows the selection of OPs instead of CVs while clicking on the resources and to ask for the parameters -- a side menu shows the list of actions
  \end{enumerate}

  
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              SECTION
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example Applications} \label{sec:evaluation}
Some applications have been created to explore the potential of the framework for building UbiApps. Although the example applications are simple, and alone does not justify the deploy of the \textit{SmartAndroid} in the environment, they have allowed us to validate the features provided by the framework and achieved by the \textit{SmartAndroid}. They also have demonstrated the possibility of the parallel running of UbiApps, what is similar to an operation system where different processes run separately but in the same system. Within the \textit{SmartAndroid}, UbiApps run separately but in the same IE.% and can share resources, 

% In this section we will elaborate over the SmartLiC application, and next we will briefly talk about the others.
In the subsections that follows we will elaborate over some UbiApps that have been developed, or are still in development, in the course of the project. Besides these applications we have also implemented some context rules, such as the `Forgotten Stove'', that have appeared throughout the text, using the context rules parser. After the start of the \textit{SmartAndroid }a factory gets all context rules stored in JSON and parses them, creating the CIs and actuators instances. 
% the SmartLiC, the MediaFollowMe, remote control type applications where resources are controlled remotely by another resource (in this case, a smartphone ), among other applications. A future work is to install a system in Ambi home care health, as in ~ \ cite {} carvalho2010sciads.
  
  \subsection{Tic-Tac-Toe}
  After the implementations of the basic features of the framework, including the communication mechanisms, we have implemented a distributed Tic-Tac-Too game, where a player can defy another player (or AI player) placed anywhere in the IE. We have used as devices two smartphones.
  
  In this implementation we have created RAs for both the players and the board. The players subscribe to the board and vice-versa, thus each movement performed by the player is set on the board through RPC, commands from this player are locked and the movement is sent to the other player, the same happens to the second player, and so on. One goal of this implementation was to verify the capability of the framework to make the construction of distributed systems easier.
  
  \subsection{SmartLiC}
%   primeiramente vc cria um skeleton para a regra
% 
% depois vc pega cada cômodo e de cada um deles faz
  % pega a lampada 
%   pega o sensor de presença
%   cria um CI com a regra e as devidas referencias
%   instancia atuador desligador de lampadas
%   subscreve atuador no ic


  % [smartlic]
  The Smart Light Control (SmartLic) application aims at the clever use of lighting in homes in order to save power consumption, since it is responsible for the largest range of consumption in residential environments. The application uses presence sensors to identify the location of people inside each room, and decide which lamps should be turned on and off. Hence it prevents the forgetting of lamps turned on, and may lit some lamp if a user enters a room at night and if nobody is at sleep in that room. 
  % ref to the 'largest range of consumption in residential environments'?
  
  The PIPA has allowed us to test this application. We instantiated lamp simulators for each room and an avatar for a user, and also a simulator for day light sensor. Next context rules were created for each room of the house. The following enumeration shows the initialization routine of the SmartLiC UbiApp (only covering the aspect of turning lamps off).
  %Next context rules were created by filling a skeleton of a rule written in json, what caused the instantiation of a CI and actuator for each room.  If the avatar is dragged, in the PIPA, from a room and dropped in another, and the specified time passes, the the lamp is turned off.
  \begin{enumerate}
   \item Create a context rule skeleton in JSON
   \item Get the rooms from the house
   \item Get the lamp and presence sensor of each room and fill the rule expression skeleton
   \item Instantiate a CI with the rule expression
   \item Instantiate a actuator to perform the actions declared in the context rule skeleton
   \item Bind the CI and the actuator
   \item Repeat this for each room
  \end{enumerate}
  
  The event of a user entering some room is triggered when the avatar is dragged from one room and dropped on another. The CI has a timer associated with the expression so, when the rule is valid, the timer is fired. If the context changes and the rule is invalidated then the timer is stopped, otherwise the evaluation is completed with a valid rule and the subscribers must be notified. Then the actuator turns off the light of the first room.
  
  There were also rules composed for turning on the light of the room that the user enters if it is day (based on a day light sensor simulator) and if nobody is at sleep in the room (based on another CI). 
  
  Another feature that we will implement as a future work is a house security mode, that users may activate if they are traveling or just have left the house alone. The basic operation is to turn lamps on and off as if users were at home, thus deceiving potential thieves. The choices of which lamps to turn on and off can follow real sampled patterns, stored in a log file, to mimic realistic living scenarios.
  
  The SmartLiC allowed us to validate two features of the RLS, which are the discovery of rooms and the RAs of some specific type within the room (i.e. the lamps and presence sensors). In this UbiApp we also have created a set of context rules with timers using the context rules parser (including CI and actuators). And the PIPA were well explored in this implementation, since we has shown the triggering of many events in parallel and multiple users cohabiting the same IE.
% 
%   After the start of the context rules, 
%   \begin{enumerate}
%    \item On event received, get the sender, the 
%   \end{enumerate}

%   \begin{lstlisting}[caption=Context Interpretation by the SmartLiC, mathescape] 
%   $\textit{//Initialization}$
%   placeList = SLR.getPlaces() $\textit{//Get rooms}$
%   for each place from placeList: $\textit{//Selects a room from the list}$
%       lampAR = SDR.search(Lamp, place) $\textit{//Get lamps from the room}$
%       presAR = SDR.search(Presence, place) $\textit{//Get presence sensor from the room}$
%       configList.add(lampAR, presAR, lampAR.turnOff) $\textit{//Stores configuration}$
%   rule = Lamp.on $\land$ $\lnot$(Presence.occupied) $\land$ T > T$_{max}$ $\textit{//Rule function}$
%   subscribeTo(configList) $\textit{//Subscribes to lamps and presence sensors}$
% 
%   $\textit{//Context rule evaluation}$
%   on event received (ar_ref, vc, value): $\textit{//Notification received}$
%       config = configList(ar_ref, vc) $\textit{//RA configuration selection}$
%       if (evaluate(rule, config)) then: $\textit{//Evaluates rule with configuration}$
% 	  invoke(config.getActions()) $\textit{//Calls action}$
%   \end{lstlisting}

%   \begin{algorithmic}
%   \STATE $asdf$
%   \FORALL{$asdf$ in $asdf$}
%     \STATE $asdf$
%   \ENDFOR
%   
%   \ONEVENT{$(ra, cv, value)$}
%     \STATE $asdf$
%   \ENDEVENT
%   \end{algorithmic}

%   \begin{algorithmic}
%   \STATE $rule \leftarrow Lamp.on \land \lnot(Presence.occupied) \land T > T_{max}$
%   \STATE $placeList \leftarrow RLS.getPlaces()$
%   \FORALL{$place$ in $placeList$}
%     \STATE $lampRA \leftarrow RDS.search(Lamp, place)$
%     \STATE $presRA \leftarrow RDS.search(Presence, place)$
%     \STATE $rule$
%     \STATE $RAs.add(presRA)$
%     \STATE $new ContextInterpreter()$
%   \ENDFOR
%   \STATE $rule \leftarrow Lamp.on \land \lnot(Presence.occupied) \land T > T_{max}$
%   \STATE $subscribeTo(RAs)$
%   \end{algorithmic}
%   
%   
%   \begin{algorithmic}
%   \STATE $placeList \leftarrow RLS.getPlaces()$
%   \FORALL{$place$ in $placeList$}
%     \STATE $lampRA \leftarrow RDS.search(Lamp, place)$
%     \STATE $presRA \leftarrow RDS.search(Presence, place)$
%     \STATE $configList.add(lampRA, presRA, lampRA.turnOff)$
%   \ENDFOR
%   \STATE $rule \leftarrow Lamp.on \land \lnot(Presence.occupied) \land T > T_{max}$
%   \STATE $subscribeTo(configList)$
%   \end{algorithmic}

  
  \subsection{Remote Controls} \label{subsec:remote}
  Considering that the users would want to have some control over the resources within the IE, we have implemented remote controls to interact with them specifically. The same way that users nowadays have a TV control, enabling them with full control over the device without much effort; using the framework that task will be easily extended to the diverse range of devices present in the IE.
    
  For implementing a lamp remote control, as shown on the Figure~\ref{fig:remotecontrol}, we are using a prototyping board called BeagleBone~\cite{Beagle2012}. The board, on one side, is capable of turning a lamp on and off (lamp's OPs) and, on the other side, it implements a RA for the lamp which is registered in the IE. A graphical interface for the lamp can remotely call these OPs of the lamp, and it is also subscribed to the Lamp RA, what allows the remote control being aware of the lamp status.
  
  \begin{figure}[ht]
  \centering
  \includegraphics[width=2.5in]{figures/beagle-lamp.pdf}
  \caption{Remote Control} %PIPA
  \label{fig:remotecontrol}
  \end{figure}
  
  \subsection{Prenda Game}
%   um agente pode saber quais recursos mais próximo de um ponto de referência específico
  The Prenda is a ubiquitous game implemented for the \textit{SmartAndroid} where the goal is to find a gift hidden somewhere in the house. The player moves inside the house and gets tips on where to find the gift while competing with others, the one who finds the gift first is the winner. This game has a different concept of other common digital games, since it explores elements in the IE and thus offers a different experience for kids. 
  
  This game was implemented with simulated resources and using the PIPA. The players were represented with avatars and their location were updated with the drag and drop of the avatars over the map. 
  
%   The player has a layout map of the house where you can find the move to attach the extent that the movement occurs, the game informs the person's subjective closeness with the gift (by the number of points in the message text) to that is found. The game allows the participation of multiple players for the environment, to get a winner the gift is repositioned to the new game. The game takes place in a simulated environment, using PIPA to simulate the movement of avatars of people participating.
  
  \subsection{MediaFollowMe}
  
  The \mbox{MediaFollowMe} application enables the user to be followed by any kind of media stream (e.g. video, audio) while he walks inside the IE. By the time the user launches this UbiApp and chooses the device in which the media stream he wants to be followed, the application will take care of the user's location changes and automatically play, pause or migrate the media to the closest device capable of displaying it.
  %FIXME write it better
  
  To illustrate that, consider a user watching a movie on a TV using a DVD player in his bedroom. When the user leaves his bedroom and walks to the living room, the system fires an event. As the UbiApp is subscribed to this event, it receives a notification informing that the user has left/arrived some room (and which room) and can migrate the media to the proper device, preferably inside that room.

%   TODO: [review of capabilities]

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              SECTION
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion} \label{sec:conclusion}
% [framework main features]
In the present paper we have proposed a framework that address some major issues that are found in the construction of ubiquitous applications, both for developers as for end-users. We have focused on three challenges, that have guided the development of the framework. For dealing with the heterogeneity of devices present in the intelligent environment we have created the Resource Agent abstraction that encapsulates the mechanisms to interact with physical and also virtual resources, and includes synchronous and asynchronous communication mechanisms. The variety of context information and Resource Agents is catered by the Context Variable publishing mechanism, which allows the creation of customized rules; the rules define Context Interpreters that are responsible for aggregating context information, providing it at a higher level. And for the resource availability issue we have created the PIPA, which is a software that helps the prototyping and testing of ubiquitous applications through a easy to use interface, and allows the visualizations of applications running in a environment populated with real and simulated devices.



% The variety of context information and services is achieved by the definition of Context Interpreters that are responsible for aggregating context information, providing it in a higher level. 

% The variety of context information and services is achieved by the context variable feature, thus allowing the creation of customized context rules that define Context Interpreters that are responsible for aggregating context information, providing it in a higher level. 
% 
% The variety of context information and services is achieved by the context variable feature. 
% 
% The context variable feature allows the creation of customized context rules, that define Context Interpreters, which allows the creation of customized rules.

% [smartandroid]
The concepts of the framework were implemented as a middleware called \textit{SmartAndroid}. The \textit{SmartAndroid} provides an API for developers and a set of basic services, that enables the construction of the intelligent environment. The core management services are the resource register service, that includes a naming service; the resource discovery service, that performs searches on registered resources based on different criteria; the resource location service, that also performs searches but based on the location and proximity of resources and/or users; and the security management service, that ensures the limits of users and applications within the environment and allows the customization. 

% [future work]
% [more complex resource discovery]
% [aggregate other security concerns]
% [machine learning and data mining]
% [internet of things - expand to internet]
As future work we plan to extend the framework to allow more complex queries in the resource discovery service, what nowadays is still strict; adapt the communication mechanism for using web services, and get our approach closer to the concept of the Internet of Things; further research on other security concerns; provide mechanisms to avoid/solve potential conflicts on context rules; aggregate machine learning techniques that will enable a better understanding of user preferences, and will make possible the offering of context rules and other helping services; improve the PIPA and evaluate its usability, using methodologies of human-machine interface; and son on.


   % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              SECTION
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% use section* for acknowledgement
\section*{Acknowledgment}
The authors would like to thank CNPq (Federal Research Funding Agency) and FAPERJ (Rio de Janeiro State Research Funding Agency) for partial funding of this work.


% references section
\bibliographystyle{IEEEtran}
\bibliography{references}




% that's all folks
\end{document}
